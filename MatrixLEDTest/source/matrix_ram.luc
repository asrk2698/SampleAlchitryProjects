module matrix_ram #(
  // 32 by 64 LED matrix by default, separated into top-16 rows and bottom 16-rows
  // both halves row i are written together for all rows 0 to 15 in a rapid loop 
  ADDRESS_SIZE = 4 : ADDRESS_SIZE > 0, //width of the address field (ABCD signals for matrix_led) 
  MATRIX_WIDTH = 64 : MATRIX_WIDTH > 0 //number of LEDs per row in the matrix
  )(
    input clk,  // clock
    input rst,
    input row_address[ADDRESS_SIZE],
    input col_address[$clog2(MATRIX_WIDTH)],
    output top_out[3], // bgr
    output bottom_out[3] // bgr
  ) {

  
    simple_dual_ram top_ram(#SIZE(3), #DEPTH(MATRIX_WIDTH*$pow(ADDRESS_SIZE, 2)), .rclk(clk), .wclk(clk));
    simple_dual_ram bottom_ram(#SIZE(3), #DEPTH(MATRIX_WIDTH*$pow(ADDRESS_SIZE, 2)), .rclk(clk),  .wclk(clk));
    
    fsm ram_state(.clk(clk)) = {LOAD_ADDRESS, LOAD_WAIT, LOOP};
  
  
    const ROW_DATA_BOTTOM = {3b000, 3b100, 3b010, 3b001}; // 64 by 3 : B0 G0 R0  per entry, index[0] is at the bottom right
    const ROW_DATA_TOP = {3b000, 3b101, 3b010, 3b110}; // 64 by 3 : B G R  per entry, index[0] is at the bottom right
  
    dff data_address[2](#INIT(0),.clk(clk));
   
      
    // to write to all 3-bit cells in top_ram and bottom_ram 
    // for 64 by 32 matrix, there are 64 by 16 cells in each ram, each cell contains 3 bit, so ram_writer_address is 10 bit long
    dff ram_writer_address[$clog2(MATRIX_WIDTH*$pow(ADDRESS_SIZE, 2))](#INIT(0), .clk(clk), .rst(rst));
  
 
  always {
  
      top_ram.raddr = 0;
      top_ram.waddr = 0;
      top_ram.write_data = 0;
      top_ram.write_en = 0;
      
      bottom_ram.raddr = 0;
      bottom_ram.waddr = 0;
      bottom_ram.write_data = 0;
      bottom_ram.write_en = 0; 
    
      top_out = 0;
      bottom_out = 0;
 
      
      case(ram_state.q){
          ram_state.LOAD_ADDRESS:
            top_ram.waddr = ram_writer_address.q;
            bottom_ram.waddr = ram_writer_address.q;
            top_ram.write_data = ROW_DATA_TOP[data_address.q];
            bottom_ram.write_data = ROW_DATA_BOTTOM[data_address.q];
            top_ram.write_en = b1;
            bottom_ram.write_en = b1;
            ram_state.d = ram_state.LOAD_WAIT;
            if (&ram_writer_address.q == 1){
                ram_state.d = ram_state.LOOP;
            }
          
          ram_state.LOAD_WAIT:
            //advance write address by 1
            ram_writer_address.d = ram_writer_address.q + 1;
            data_address.d = data_address.q +1;
            ram_state.d = ram_state.LOAD_ADDRESS;
         
          ram_state.LOOP:
            //provide output from ram after writing is done
            top_ram.raddr = row_address * MATRIX_WIDTH + col_address;
            bottom_ram.raddr = row_address * MATRIX_WIDTH + col_address;
            top_out = top_ram.read_data;
            bottom_out = bottom_ram.read_data;
            ram_state.d = ram_state.LOOP;
    }
      
 
      
   
     
  }
}
